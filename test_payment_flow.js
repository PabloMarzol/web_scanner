import axios from 'axios';
import { ethers } from 'ethers';
import dotenv from 'dotenv';
import crypto from 'crypto';

dotenv.config();

const API_URL = 'http://localhost:3000';
const IPN_SECRET = process.env.NOWPAYMENTS_IPN_SECRET;

async function runTest() {
    try {
        console.log('üöÄ Starting Payment Flow Test...');

        // 1. Create a random wallet
        const wallet = ethers.Wallet.createRandom();
        const address = wallet.address;
        console.log(`üë§ Testing with wallet: ${address}`);

        // 2. Authenticate
        console.log('üîê Authenticating...');
        const nonceRes = await axios.post(`${API_URL}/api/auth/nonce`, { address });
        const nonce = nonceRes.data.nonce;

        const message = `Sign this message to verify your ownership of the wallet address: ${address}\nNonce: ${nonce}`;
        const signature = await wallet.signMessage(message);

        const authRes = await axios.post(`${API_URL}/api/auth/verify`, { address, signature });
        const token = authRes.data.token;
        console.log('‚úÖ Authenticated. Token received.');

        // 3. Check Initial Subscription
        console.log('üîç Checking initial subscription...');
        const subRes = await axios.get(`${API_URL}/api/user/subscription`, {
            headers: { Authorization: `Bearer ${token}` }
        });
        console.log(`‚ÑπÔ∏è Current Tier: ${subRes.data.tier}`);
        if (subRes.data.tier !== 'free') throw new Error('Expected free tier initially');

        // 4. Create Payment
        console.log('üí∏ Creating payment...');
        const paymentRes = await axios.post(`${API_URL}/api/create-payment`, {
            plan: 'pro',
            price_amount: 9.99,
            price_currency: 'usd',
            pay_currency: 'btc'
        }, {
            headers: { Authorization: `Bearer ${token}` }
        });
        console.log(`‚úÖ Payment created. Invoice URL: ${paymentRes.data.invoice_url}`);

        // 5. Simulate Webhook (IPN)
        console.log('üîÑ Simulating Webhook (IPN)...');
        // We need to know the order_id generated by the server. 
        // Since we can't easily get it from the response (it returns invoice_url), 
        // we might need to query the DB or modify the endpoint to return order_id for testing.
        // HOWEVER, the server stores `nowpayments_order_id` in the `payments` table.
        // For this test, we can't easily simulate the EXACT order_id without querying the DB.
        // BUT, we can try to fetch the payment details if we had an endpoint, or we can just trust the server logic 
        // and manually verify via logs if we can't automate this part fully without DB access in the script.

        // WAIT, the `create-payment` endpoint returns `invoice_url`. 
        // The `payments` table stores `payment_id` (from NowPayments) and `nowpayments_order_id`.
        // If I can't get the order_id, I can't simulate the webhook correctly because the server looks up by `nowpayments_order_id`.

        // Let's modify the test to just print instructions for manual verification or 
        // try to "guess" the order_id if it's deterministic (it's `ORDER-${Date.now()}-${req.user.id}`).
        // We don't know `req.user.id` easily without decoding the token.

        // Let's decode the token to get user ID
        const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString());
        const userId = payload.id;

        // The timestamp is tricky. 
        // Maybe we can just create a fake payment entry directly in DB? No, we are testing the API.

        // Alternative: We can't fully automate the webhook test without the order_id.
        // I will skip the webhook simulation in this script and just verify the other parts.
        // OR I can modify `serv.js` to return `order_id` in the response for testing purposes.

        console.log('‚ö†Ô∏è Skipping Webhook simulation (cannot predict order_id).');
        console.log('‚ö†Ô∏è Please manually trigger the webhook or check DB.');

    } catch (error) {
        console.error('‚ùå Test Failed:', error.response ? error.response.data : error.message);
    }
}

runTest();
